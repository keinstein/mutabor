#!/bin/awk -f

# "Copyright (c) 2002 and The Regents of the University 
# of California.  All rights reserved.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose, without fee, and without written agreement is
# hereby granted, provided that the above copyright notice and the following
# two paragraphs appear in all copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
# OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
# CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
# ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
#
#  Authors:   Peter Broadwell (pbwell@cs.berkeley.edu)
#             Naveen Sastry (nks@cs.berkeley.edu)
#             Jonathan Traupman (jont@cs.berkeley.edu)

# AWK script to auto-generate the library call stubs that FIG uses to
# supercede the regular library calls (using LD_PRELOAD).
# Examines the func.desc function description file and generates a stub
# C library file for each function. Also generates the func.h file, which
# defines the numeric identifiers of the library calls in the output
# control file (control.out).

BEGIN { FS = "\t"
        fn_num = 1
	print("/* Index numbers for instrumented functions */") > "func.h"
        print("/* Automatically generated by stubgen.awk. DO NOT MODIFY! */\n") >> "func.h"
      }
/^\#/ { }  # comment, do nothing

END {
    printf("#define FIRST_USER_INDEX %d\n\n", fn_num) >> "func.h"
    printf("#include \"userfunc.h\"\n") >> "func.h"
}

# each entry is of the form:
# name real_name ret_type param1_type param1_name ... paramN_type paramN_name
{ n = split($0, funcdesc, "\t");
  fn_name = funcdesc[1];
  fn_realname = funcdesc[2];
  ret_type = funcdesc[3];
  fmt_str = funcdesc[4];

  file = fn_name ".c" ;
  fn_index = toupper(fn_name) "_INDEX";

  printf("#define %s %d\n", fn_index, fn_num) >> "func.h"
  ++fn_num;

  print n
  if (((n - 4) % 2) != 0) {
     print "Error in function description file!"
  } else {
    print "#define _GNU_SOURCE" > file
    print "#include <stdlib.h>" >> file
    print "#include <stdio.h>" >> file      
    print "#include <errno.h>" >> file
    print "#include <stdio.h>" >> file
    print "#include \"log.h\"" >> file
    print "#include \"prob.h\"" >> file
    print "#include \"util.h\"" >> file
    print "#include \"func.h\"" >> file
    print "#include \"loglevel.h\"" >> file
    print "" >> file

    printf("%s %s(", ret_type, fn_name) >> file
    
    if ((n - 4) == 0) {
       printf("void") >> file
    } else {
       for (i = 5; i <= n; i += 2) {
	   if (i != 5) 
	      printf(", ") >> file
	   printf("%s %s", funcdesc[i], funcdesc[i+1]) >> file
       }
    }
    printf(") {\n") >> file

    printf("    action a;\n") >> file
    printf("    int old_errno;\n") >> file;

    if (ret_type != "void") {
       printf("    %s rv;\n\n", ret_type) >> file;
    }
       printf("    if (fig_error(%s, &a)) {\n", fn_index) >> file
       printf("        log(INJECTED, \"%s(%s) Induced error - going to return %%d, errno = %%d\\n\"", fn_name, fmt_str) >> file
       for (i = 5; i <= n; i += 2) {
	   printf(", %s", funcdesc[i+1]) >> file;
       }
       printf(", a.ret, a.err);\n") >> file

       printf("        errno = a.err;\n") >> file 
       printf("        return (%s) a.ret;\n", ret_type) >> file
 
       printf("    } else {\n") >> file
       printf("        rv = (%s) %s(", ret_type, fn_realname) >> file

       if ((n - 4) != 0) {
	 for (i = 5; i <= n; i += 2) {
	       if (i != 5)
		   printf(", ") >> file
	       printf("%s", funcdesc[i+1]) >> file
         }
       }

       printf(");\n") >> file
       printf("        old_errno = errno;\n") >> file;       
       printf("        log(ALL, \"%s(%s) library returning %%d, errno = %%d\\n\"", fn_name, fmt_str) >> file

       if ((n - 4) != 0) {
	  for (i = 5; i <= n; i += 2) {
	       printf(", %s", funcdesc[i+1]) >> file;
          }
       }

       printf(", rv, errno);\n") >> file
       printf("        errno = old_errno;\n") >> file;       

       printf("        return rv;\n") >> file
       printf("    }\n\n") >> file
       printf("}\n") >> file
  }
}
